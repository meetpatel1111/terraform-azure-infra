name: Terraform Azure IaC (Remote-state only)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment (drives env/<environment>.tfvars)"
        type: choice
        required: true
        options: [dev, uat, prod]
        default: dev
      tf_action:
        description: "Terraform action"
        type: choice
        options: [plan, apply, destroy, refresh, import]
        required: true
        default: plan
      environment_type:
        description: "Env type code (np/p) for naming (locals.tf)"
        type: choice
        options: [np, p]
        required: true
        default: np
      tf_version:
        description: "Terraform version"
        type: string
        required: false
        default: "1.7.5"
      backend_rg:
        default: "tfstate-uks-shared-rg"
        description: "Backend: Resource Group"
        type: string
        required: true
      backend_storage_account:
        default: "sttfstateshared"
        description: "Backend: Storage Account"
        type: string
        required: true
      backend_container:
        default: "tfstate"
        description: "Backend: Blob Container"
        type: string
        required: true
      backend_key_prefix:
        description: "Backend key prefix, e.g. iac/core"
        type: string
        required: false
        default: "iac/core"
      import_pairs:
        description: |-
          (import) One per line; '=' or '|' separator.
          Example:
            azurerm_resource_group.example=/subscriptions/.../resourceGroups/my-rg-prod
            azurerm_key_vault_access_policy.current[0]|/subscriptions/.../objectId/<GUID>
        type: string
        required: false
        default: ""

# One run per env at a time to avoid state contention
concurrency:
  group: terraform-${{ github.workflow }}-${{ inputs.environment }}
  cancel-in-progress: false

jobs:
  terraform:
    name: Terraform ${{ inputs.tf_action }} (${{ inputs.environment }})
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    defaults:
      run:
        shell: bash

    env:
      # Azure creds for Terraform provider (azurerm)
      ARM_CLIENT_ID:       ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET:   ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID:       ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      # Common TF vars
      TF_VAR_environment_type: ${{ inputs.environment_type }}
      TF_VAR_environment_name: ${{ inputs.environment }}

      # Backend coordinates (CI never creates/overwrites state)
      BACKEND_RG:        ${{ inputs.backend_rg }}
      BACKEND_SA:        ${{ inputs.backend_storage_account }}
      BACKEND_CONTAINER: ${{ inputs.backend_container }}
      BACKEND_KEY:       ${{ inputs.backend_key_prefix }}/${{ inputs.environment }}.tfstate

      TF_IN_AUTOMATION: "true"
      TF_INPUT: "false"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Guard – no *.tfstate committed
        run: |
          set -euo pipefail
          bad=$(git ls-files | grep -E '\.tfstate(\.backup)?$' || true)
          if [ -n "$bad" ]; then
            echo "ERROR: The repo contains state files:"
            echo "$bad"
            exit 1
          fi

      - name: Set Terraform version
        run: echo "TF_VERSION=${{ inputs.tf_version }}" >> "$GITHUB_ENV"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS_JSON }}

      - name: Display Azure context
        run: |
          az account show
          echo "Backend key: ${BACKEND_KEY}"

      - name: Select tfvars
        id: tfvars
        run: |
          set -euo pipefail
          FILE="env/${{ inputs.environment }}.tfvars"
          if [ ! -f "$FILE" ]; then
            echo "Missing env file $FILE"
            exit 1
          fi
          echo "file=$FILE" >> "$GITHUB_OUTPUT"

      - name: Derive location from tfvars (best effort)
        run: |
          set -euo pipefail
          TFVARS_FILE="${{ steps.tfvars.outputs.file }}"
          LOC=$(awk -F'"' '/^[[:space:]]*location[[:space:]]*=/ {print $2; exit}' "$TFVARS_FILE" || true)
          if [ -z "$LOC" ]; then LOC="UK South"; fi
          echo "Using location: $LOC"
          echo "BACKEND_LOCATION=$LOC" >> "$GITHUB_ENV"

      # --------- Use ACCOUNT KEY to verify remote state blob exists (no creation) ----------
      - name: Get backend storage account key
        id: get_sa_key
        run: |
          set -euo pipefail
          STORAGE_KEY=$(az storage account keys list \
            -g "${BACKEND_RG}" \
            -n "${BACKEND_SA}" \
            --query "[0].value" -o tsv)
          if [ -z "$STORAGE_KEY" ]; then
            echo "ERROR: Could not obtain storage account key for ${BACKEND_SA}."
            exit 1
          fi
          echo "storage_key=$STORAGE_KEY" >> "$GITHUB_OUTPUT"

      - name: Verify backend blob exists (account key)
        env:
          STORAGE_KEY: ${{ steps.get_sa_key.outputs.storage_key }}
        run: |
          set -euo pipefail
          if ! az storage blob show \
            --account-name "${BACKEND_SA}" \
            --account-key "${STORAGE_KEY}" \
            --container-name "${BACKEND_CONTAINER}" \
            --name "${BACKEND_KEY}" >/dev/null 2>&1; then
            echo "ERROR: Backend state blob does not exist or is inaccessible:"
            echo "  sa=${BACKEND_SA}"
            echo "  container=${BACKEND_CONTAINER}"
            echo "  key=${BACKEND_KEY}"
            echo "Refusing to proceed to avoid creating or overwriting state."
            exit 1
          fi
          echo "Remote backend state is present."

      - name: Terraform init (remote backend, reconfigure)
        run: |
          terraform init -reconfigure \
            -backend-config="resource_group_name=${BACKEND_RG}" \
            -backend-config="storage_account_name=${BACKEND_SA}" \
            -backend-config="container_name=${BACKEND_CONTAINER}" \
            -backend-config="key=${BACKEND_KEY}"

      - name: Guard – state is readable (pull only)
        run: |
          set -euo pipefail
          if ! terraform state pull > /dev/null 2>&1 ; then
            echo "ERROR: Could not pull remote state. Aborting to prevent any state mutation."
            exit 1
          fi
          echo "Remote state pull OK."

      - name: Terraform fmt
        run: terraform fmt -check -recursive

      - name: Terraform validate
        run: terraform validate

      # ------------------------------- IMPORT -------------------------------
      - name: Terraform import
        if: ${{ inputs.tf_action == 'import' }}
        run: |
          set -euo pipefail
          TFVARS_FILE="${{ steps.tfvars.outputs.file }}"
          printf "%s\n" "${{ inputs.import_pairs }}" > imports.txt

          do_import () {
            local address="$1"
            local id="$2"
            echo "::group::terraform import ${address}"
            echo "ID: ${id}"
            terraform import -input=false -lock=true -lock-timeout=10m -var-file="${TFVARS_FILE}" "${address}" "${id}"
            terraform state show "${address}" || true
            echo "::endgroup::"
          }

          if [ -s imports.txt ] && [ "$(wc -c < imports.txt)" -gt 1 ]; then
            echo "Processing multiple imports from import_pairs..."
            while IFS= read -r line; do
              line="$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
              [ -z "$line" ] && continue
              if echo "$line" | grep -q '='; then
                addr="${line%%=*}"
                rid="${line#*=}"
              else
                addr="${line%%|*}"
                rid="${line#*|}"
              fi
              [ -z "$addr" ] || [ -z "$rid" ] && { echo "Skipping malformed line: $line"; continue; }
              do_import "$addr" "$rid"
            done < imports.txt
          else
            echo "No import_pairs provided; nothing to import."
          fi
          echo "Imports completed."

      # ------------------------------- PLAN -------------------------------
      - name: Terraform plan (writes <env>.tfplan)
        if: ${{ inputs.tf_action == 'plan' }}
        run: |
          set -euo pipefail
          TFVARS_FILE="${{ steps.tfvars.outputs.file }}"
          terraform plan \
            -input=false \
            -lock=true -lock-timeout=10m \
            -var-file="$TFVARS_FILE" \
            -out="${{ inputs.environment }}.tfplan"

      - name: Upload plan artifact
        if: ${{ inputs.tf_action == 'plan' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.environment }}.tfplan
          path: ${{ inputs.environment }}.tfplan
          if-no-files-found: error
          retention-days: 10

      # ------------------------------- APPLY -------------------------------
      - name: Guard – backend non-empty before apply
        if: ${{ inputs.tf_action == 'apply' }}
        run: |
          set -euo pipefail
          pulled=$(mktemp)
          terraform state pull > "$pulled"
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y >/dev/null
            sudo apt-get install -y jq >/dev/null
          fi
          count=$(jq '.resources | length' "$pulled" 2>/dev/null || echo 0)
          if [ "$count" -eq 0 ]; then
            echo "ERROR: Remote state appears empty. Refusing to apply to avoid clobbering existing infra."
            exit 1
          fi
          echo "Remote state has $count tracked resources – OK."

      - name: Terraform apply (create plan and apply)
        if: ${{ inputs.tf_action == 'apply' }}
        run: |
          set -euo pipefail
          TFVARS_FILE="${{ steps.tfvars.outputs.file }}"
          terraform plan \
            -input=false \
            -lock=true -lock-timeout=10m \
            -var-file="$TFVARS_FILE" \
            -out="${{ inputs.environment }}.tfplan"
          terraform apply -input=false -auto-approve "${{ inputs.environment }}.tfplan"

      # ------------------------------- DESTROY -------------------------------
      - name: Guard – state must not be empty before destroy
        if: ${{ inputs.tf_action == 'destroy' }}
        run: |
          set -euo pipefail
          pulled=$(mktemp)
          terraform state pull > "$pulled" || true
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y >/dev/null
            sudo apt-get install -y jq >/dev/null
          fi
          COUNT=$(jq '.resources | length' "$pulled" 2>/dev/null || echo 0)
          echo "Resource count in state: $COUNT"
          if [ "$COUNT" -eq 0 ]; then
            echo "ERROR: Backend state is empty or unreadable. Check BACKEND_KEY and access."
            exit 1
          fi

      - name: Terraform destroy
        if: ${{ inputs.tf_action == 'destroy' }}
        run: |
          set -euo pipefail
          TFVARS_FILE="${{ steps.tfvars.outputs.file }}"
          terraform plan -destroy \
            -input=false \
            -lock=true -lock-timeout=10m \
            -var-file="$TFVARS_FILE" \
            -out=tfplan-destroy
          terraform apply -input=false -auto-approve tfplan-destroy

      # ------------------------------- REFRESH -------------------------------
      - name: Terraform refresh (state-only)
        if: ${{ inputs.tf_action == 'refresh' }}
        run: |
          set -euo pipefail
          TFVARS_FILE="${{ steps.tfvars.outputs.file }}"
          terraform refresh -input=false -lock=true -lock-timeout=10m -var-file="$TFVARS_FILE"

      # ------------------------------- Diagnostics (no uploads) -------------------------------
      - name: Show backend state (resource list)
        if: ${{ always() }}
        run: |
          set -euo pipefail
          echo "Primary state blob key: ${BACKEND_KEY}"
          terraform state list || echo "(state empty or unreadable)"
