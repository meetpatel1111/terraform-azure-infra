name: Terraform Azure IaC

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment (drives env/<environment>.tfvars)"
        type: choice
        required: true
        options: [dev, uat, prod]
        default: dev
      tf_action:
        description: "Terraform action"
        type: choice
        options: [plan, apply, destroy, refresh, refresh-apply]
        required: true
        default: plan
      environment_type:
        description: "Env type code (np/p) for naming (locals.tf)"
        type: choice
        options: [np, p]
        required: true
        default: np
      location:
        description: "Azure region display name (e.g., 'UK South')"
        type: string
        required: true
        default: "UK South"
      location_code:
        description: "Short region code used in names (e.g., 'uks')"
        type: string
        required: true
        default: "uks"
      tf_version:
        description: "Terraform version"
        type: string
        required: false
        default: "1.7.5"
      backend_rg:
        default: "tfstate-uks-shared-rg"
        description: "Backend: Resource Group"
        type: string
        required: true
      backend_storage_account:
        default: "sttfstateshared"
        description: "Backend: Storage Account"
        type: string
        required: true
      backend_container:
        default: "tfstate"
        description: "Backend: Blob Container"
        type: string
        required: true
      backend_key_prefix:
        description: "Backend: key prefix (file path prefix for state), e.g., 'iac/core'"
        type: string
        required: false
        default: "iac/core"

jobs:
  terraform:
    name: Terraform ${{ inputs.tf_action }} (${{ inputs.environment }})
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    env:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      TF_VAR_environment_type: ${{ inputs.environment_type }}
      TF_VAR_environment_name: ${{ inputs.environment }}
      TF_VAR_location: ${{ inputs.location }}
      TF_VAR_location_code: ${{ inputs.location_code }}

      BACKEND_RG: ${{ inputs.backend_rg }}
      BACKEND_SA: ${{ inputs.backend_storage_account }}
      BACKEND_CONTAINER: ${{ inputs.backend_container }}
      BACKEND_KEY: ${{ inputs.backend_key_prefix }}/${{ inputs.environment }}.tfstate

      TF_IN_AUTOMATION: "true"
      TF_INPUT: "false"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set Terraform version
        run: echo "TF_VERSION=${{ inputs.tf_version }}" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Azure Login (OIDC or secret-based)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS_JSON }}
          # OR (OIDC):
          # client-id: ${{ secrets.AZURE_CLIENT_ID }}
          # tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          # subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Display Azure context
        run: |
          az account show
          echo "Using backend key: ${BACKEND_KEY}"

      # Ensure remote backend exists
      - name: Ensure backend state storage exists (RG/SA/Container)
        env:
          LOCATION: ${{ inputs.location }}
        run: |
          set -euo pipefail
          echo "Ensuring resource group '${BACKEND_RG}' in '${LOCATION}'..."
          az group create -n "${BACKEND_RG}" -l "${LOCATION}" >/dev/null

          echo "Checking storage account '${BACKEND_SA}'..."
          if ! az storage account show -n "${BACKEND_SA}" -g "${BACKEND_RG}" >/dev/null 2>&1; then
            echo "Creating storage account '${BACKEND_SA}'..."
            az storage account create \
              -n "${BACKEND_SA}" \
              -g "${BACKEND_RG}" \
              -l "${LOCATION}" \
              --sku Standard_LRS \
              --kind StorageV2 \
              --allow-blob-public-access false \
              --min-tls-version TLS1_2 >/dev/null
          else
            echo "Storage account exists."
          fi

          echo "Configuring blob service protections..."
          az storage account blob-service-properties update \
            -n "${BACKEND_SA}" -g "${BACKEND_RG}" \
            --enable-versioning true \
            --enable-change-feed true \
            --enable-delete-retention true \
            --delete-retention-days 7 \
            --enable-container-delete-retention true \
            --container-delete-retention-days 7 >/dev/null

          echo "Ensuring container '${BACKEND_CONTAINER}'..."
          if ! az storage container show \
              --name "${BACKEND_CONTAINER}" \
              --account-name "${BACKEND_SA}" \
              --auth-mode login >/dev/null 2>&1; then
            az storage container create \
              --name "${BACKEND_CONTAINER}" \
              --account-name "${BACKEND_SA}" \
              --auth-mode login >/dev/null
          else
            echo "Container exists."
          fi

          echo "âœ… Backend ready."

      # Optional but recommended: grant data-plane RBAC for blob uploads via AAD
      - name: Ensure RBAC for blob upload (Storage Blob Data Contributor)
        run: |
          set -euo pipefail
          SCOPE_ID=$(az storage account show -n "${BACKEND_SA}" -g "${BACKEND_RG}" --query id -o tsv)
          echo "Assigning 'Storage Blob Data Contributor' to principalId ${ARM_CLIENT_ID} on ${SCOPE_ID} (idempotent)..."
          az role assignment create \
            --assignee-object-id "${ARM_CLIENT_ID}" \
            --assignee-principal-type ServicePrincipal \
            --role "Storage Blob Data Contributor" \
            --scope "${SCOPE_ID}" >/dev/null || true

          echo "Waiting for RBAC propagation..."
          for i in {1..12}; do
            if az storage container list --account-name "${BACKEND_SA}" --auth-mode login >/dev/null 2>&1; then
              echo "RBAC ready."
              break
            fi
            sleep 10
          done

      - name: Select tfvars file
        id: tfvars
        run: |
          FILE="env/${{ inputs.environment }}.tfvars"
          if [ ! -f "$FILE" ]; then
            echo "ERROR: $FILE not found" >&2
            exit 1
          fi
          echo "file=$FILE" >> $GITHUB_OUTPUT

      - name: Terraform Init (remote backend)
        run: |
          terraform init \
            -backend-config="resource_group_name=${BACKEND_RG}" \
            -backend-config="storage_account_name=${BACKEND_SA}" \
            -backend-config="container_name=${BACKEND_CONTAINER}" \
            -backend-config="key=${BACKEND_KEY}"

      - name: Terraform Format Check
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: terraform validate

      # ---------- Standard Plan / Apply / Destroy (no .bin) ----------
      - name: Terraform Plan (text)
        if: ${{ inputs.tf_action == 'plan' || inputs.tf_action == 'apply' }}
        run: |
          terraform plan -no-color -var-file="${{ steps.tfvars.outputs.file }}" | tee plan-${{ inputs.environment }}.txt

      - name: Upload Plan (text)
        if: ${{ inputs.tf_action == 'plan' || inputs.tf_action == 'apply' }}
        uses: actions/upload-artifact@v4
        with:
          name: plan-${{ inputs.environment }}
          path: plan-${{ inputs.environment }}.txt
          if-no-files-found: error
          retention-days: 7

      - name: Terraform Apply (direct, no saved plan)
        if: ${{ inputs.tf_action == 'apply' }}
        run: terraform apply -auto-approve -var-file="${{ steps.tfvars.outputs.file }}"

      # Ensure backend state blob exists after apply (create if missing), and snapshot
      - name: Ensure backend tfstate exists + snapshot (apply)
        if: ${{ inputs.tf_action == 'apply' }}
        env:
          BACKEND_SA: ${{ env.BACKEND_SA }}
          BACKEND_CONTAINER: ${{ env.BACKEND_CONTAINER }}
          BACKEND_KEY: ${{ env.BACKEND_KEY }}
        run: |
          set -euo pipefail

          # If backend tfstate blob is missing, create it from current state
          EXISTS=$(az storage blob exists \
            --account-name "${BACKEND_SA}" \
            --container-name "${BACKEND_CONTAINER}" \
            --name "${BACKEND_KEY}" \
            --auth-mode login --query exists -o tsv)
          if [ "${EXISTS}" != "true" ]; then
            echo "Backend state blob not found. Creating it from current Terraform state..."
            terraform state pull > state.tfstate
            az storage blob upload \
              --account-name "${BACKEND_SA}" \
              --container-name "${BACKEND_CONTAINER}" \
              --name "${BACKEND_KEY}" \
              --file state.tfstate \
              --auth-mode login \
              --overwrite true >/dev/null
            echo "Backend state blob created: ${BACKEND_KEY}"
          else
            echo "Backend state blob exists."
          fi

          # Always upload a timestamped snapshot
          TS=$(date -u +"%Y%m%dT%H%M%SZ")
          BASE_DIR=$(dirname "${BACKEND_KEY}")
          BASE_FILE=$(basename "${BACKEND_KEY}" .tfstate)
          SNAP_BLOB="${BASE_DIR}/${BASE_FILE}/snapshots/${TS}-${GITHUB_RUN_ID}.tfstate"
          echo "Snapshotting current state to '${SNAP_BLOB}'..."
          terraform state pull > state.tfstate
          az storage blob upload \
            --account-name "${BACKEND_SA}" \
            --container-name "${BACKEND_CONTAINER}" \
            --name "${SNAP_BLOB}" \
            --file state.tfstate \
            --auth-mode login \
            --overwrite true >/dev/null
          echo "Snapshot uploaded."

      - name: Terraform Destroy (direct)
        if: ${{ inputs.tf_action == 'destroy' }}
        run: terraform destroy -auto-approve -var-file="${{ steps.tfvars.outputs.file }}"

      # ---------- Refresh-only (no .bin) ----------
      - name: Terraform Plan (refresh-only, text)
        if: ${{ inputs.tf_action == 'refresh' || inputs.tf_action == 'refresh-apply' }}
        run: |
          terraform plan -refresh-only -no-color -var-file="${{ steps.tfvars.outputs.file }}" | tee plan-refresh-${{ inputs.environment }}.txt

      - name: Upload Refresh Plan (text)
        if: ${{ inputs.tf_action == 'refresh' || inputs.tf_action == 'refresh-apply' }}
        uses: actions/upload-artifact@v4
        with:
          name: plan-refresh-${{ inputs.environment }}
          path: plan-refresh-${{ inputs.environment }}.txt
          if-no-files-found: error
          retention-days: 7

      - name: Terraform Apply (refresh-only, direct)
        if: ${{ inputs.tf_action == 'refresh-apply' }}
        run: terraform apply -refresh-only -auto-approve -var-file="${{ steps.tfvars.outputs.file }}"

      # Ensure backend state exists after refresh-apply (create if missing), and snapshot
      - name: Ensure backend tfstate exists + snapshot (refresh-apply)
        if: ${{ inputs.tf_action == 'refresh-apply' }}
        env:
          BACKEND_SA: ${{ env.BACKEND_SA }}
          BACKEND_CONTAINER: ${{ env.BACKEND_CONTAINER }}
          BACKEND_KEY: ${{ env.BACKEND_KEY }}
        run: |
          set -euo pipefail

          # If backend tfstate blob is missing, create it from current state
          EXISTS=$(az storage blob exists \
            --account-name "${BACKEND_SA}" \
            --container-name "${BACKEND_CONTAINER}" \
            --name "${BACKEND_KEY}" \
            --auth-mode login --query exists -o tsv)
          if [ "${EXISTS}" != "true" ]; then
            echo "Backend state blob not found. Creating it from current Terraform state..."
            terraform state pull > state.tfstate
            az storage blob upload \
              --account-name "${BACKEND_SA}" \
              --container-name "${BACKEND_CONTAINER}" \
              --name "${BACKEND_KEY}" \
              --file state.tfstate \
              --auth-mode login \
              --overwrite true >/dev/null
            echo "Backend state blob created: ${BACKEND_KEY}"
          else
            echo "Backend state blob exists."
          fi

          # Always upload a timestamped snapshot
          TS=$(date -u +"%Y%m%dT%H%M%SZ")
          BASE_DIR=$(dirname "${BACKEND_KEY}")
          BASE_FILE=$(basename "${BACKEND_KEY}" .tfstate)
          SNAP_BLOB="${BASE_DIR}/${BASE_FILE}/snapshots/${TS}-${GITHUB_RUN_ID}.tfstate"
          echo "Snapshotting refreshed state to '${SNAP_BLOB}'..."
          terraform state pull > state.tfstate
          az storage blob upload \
            --account-name "${BACKEND_SA}" \
            --container-name "${BACKEND_CONTAINER}" \
            --name "${SNAP_BLOB}" \
            --file state.tfstate \
            --auth-mode login \
            --overwrite true >/dev/null
          echo "Snapshot uploaded."
